<erl>

-define(CACHE_TIMEOUT, 120).

out(A) ->
    {{_, Subnet, _, _}, _Port} = A#arg.client_ip_port,
    
    Curtime = now_secs(),
    case ets:lookup(zensus_cache, Subnet) of
	[] ->
	    render_new(Subnet);
	[{Subnet, Result, Expire}] ->
	    if
		Expire < Curtime ->
		    render_new(Subnet);
		true ->
		    Result
	    end
    end.

render_new(Subnet) ->
    Answer = 
	[
	 {header, {content_type, "text/html; encoding=utf-8"}},
	 {html, [
		 "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html>\n"
		 "<html lang='en'><head>    <title>Zensus</title><body><p>"
		 "Sobald diese Seite komplett geladen ist, kann das Internet ausgeschaltet werden. "
		 "Das l√§uft alles mit JavaScript hier. Seite generiert um ",
		 generation_time(), ".</p><form>",
		 do_render(Subnet),
		 "<br /><input type='submit' value='generate' "
		 "onclick='javascript:doit(); return false' /><form /></body></html>"
		]
	 }
	],
    ets:insert(zensus_cache, {Subnet, Answer, now_secs() + ?CACHE_TIMEOUT}),
    Answer.

generation_time() ->
    {Date={Year,Month,Day},Time={Hour,Minutes,Seconds}} = erlang:localtime(),
    io_lib:format("~p:~p", [Hour, Minutes]).   

do_distinction(Rows, Subnet) ->
    {ok, C} = pgsql_pool:get_connection(zensus),
    {ok, _Cols, Rows1} = pgsql:squery(C, "SELECT qid FROM questions"),
    pgsql_pool:return_connection(zensus, C),
    Dict = lists:foldl(
	     fun({Qid}, D) ->
		     dict:store(Qid, try dict:fetch(Qid, D) of
					 Value -> Value
				     catch _:_ -> 0 end + 1, D)
	     end, dict:new(), Rows1),
    {_, _, Res} = lists:foldl(
		    fun({Qid,_,_,_}=Row, {Count1, Lastqid, L}) ->
			    Count = if Lastqid =:= Qid -> Count1;
				       true -> 0 end,
			    {Count + 1, Qid, L ++
			     case Subnet rem dict:fetch(Qid, Dict) of
				 Count ->
				     [Row];
				 _Else ->
				     []
			     end}
		    end, {0, -1, []}, Rows),
    Res.

do_render(Subnet) ->    
    {ok, C} = pgsql_pool:get_connection(zensus),
    {ok, Columns, Rows1} = pgsql:squery(C, "SELECT qid,question,question_type,data FROM questions ORDER BY qid::integer ASC"),
    pgsql_pool:return_connection(zensus, C),
    Rows = do_distinction(Rows1, Subnet),
    {JS, HTML} = lists:foldl(
		   fun({_,Question,_,_}=E, {JS, HTML}) ->
			   {JS1, HTML1} = render_question(E),
			   Itl1 = list_to_binary(yaws_api:htmlize(binary_to_list(Question))),
			   HTML2 = [<<"<h2>", Itl1/binary,
 				     "</h2><p>">>,
				    HTML1,
				    <<"</p>">>],
			   {[JS1|JS],
			    [HTML2|HTML]}
		   end, {[], []}, Rows),
    HTML1 = lists:reverse(HTML),
    Gat = genalltext(Rows),
    [
     <<"<script type='text/javascript'><!--\nfunction doit() {">>,
     JS,
     <<"text=">>,
     Gat,
     <<";\ndocument.write(' <link rel=\\'stylesheet\\' ",
       "type=\\'text/css\\' href=\\'/zensus.css\\' /><p>' + text + '</p>');return false;\n}\n-",
       "-></script>">>,
     HTML1
    ].

genalltext(Rows) ->
    [
     [<< "text", Qid/binary, " + \"</p><p>\" + " >> || {Qid,_,_,_} <- Rows],
     << "'</p>'" >>
    ].

render_question({Qid1, Question, Qtype, Data}=E) ->
    Qid = list_to_integer(binary_to_list(Qid1)),
    Data1 = binary_to_term(base64:decode(Data)),    
    Qtype1 = case Qtype of
		 <<"qtype_text">> -> <<"text">>;
		 <<"qtype_predef">> -> <<"predef">>;
		 Else -> Else
	     end,

    render_question(Qid, Data1, Qtype1).

render_question(Qid, Data1, Qtype1) ->
    case Qtype1 of
	<<"text">> ->
	    [Res|Qs] = Data1,
	    {gen_text_js(Qid, Res, length(Qs)),
	     gen_text_html(Qid, Qs)};
	<<"predef">> ->
	    {"text" ++ integer_to_list(Qid) ++ "='';" ++ gen_predef_js(Qid, Data1),
	     gen_predef_html(Qid, Data1) ++ "<br />"}
    end.

gen_text_js(Qid, Res, Len) ->
    Varname = list_to_binary("text" ++ integer_to_list(Qid)),
    Res1 = list_to_binary(js_mk_txt(Res)),
    Res2 = lists:reverse(
	     lists:foldl(fun({Len, E}, Acc) ->
				 Itl1 = list_to_binary(integer_to_list(Len - E + 1)),
				 Itl2 = list_to_binary(integer_to_list(Qid)),
				 Itl3 = list_to_binary(integer_to_list(E)),
				 [<<
				   Varname/binary, " = ", Varname/binary,
				   ".replace(/~", Itl1/binary,
				   "s/g, document.getElementById('q",
				   Itl2/binary, "a", Itl3/binary, "').value);\n"
				   >>|Acc]
			 end, [], [{Len, E} || E <- count(Len)])),
    [Varname,
     <<" = ">>,
     Res1,
     <<";\n">>,
     Res2].

gen_text_html(Qid, Qs) ->
    lists:reverse(
      lists:foldl(fun({I, T}, Acc) ->
			  Itl1 = list_to_binary(yaws_api:htmlize(T)),
			  Itl2 = list_to_binary(integer_to_list(Qid)),
			  Itl3 = list_to_binary(integer_to_list(I)),
			  [<<
			    Itl1/binary, ": <input type='text' id='q",
			    Itl2/binary, "a",
			    Itl3/binary, "' /><br />"
			    >>|Acc]
		  end, [], enumerate(Qs))).
    
gen_predef_js(Qid, Qs) ->
    Varname = list_to_binary("text" ++ integer_to_list(Qid)),
    Itl1 = list_to_binary(integer_to_list(Qid)),
    lists:reverse(
      lists:foldl(fun({E, {_, T}}, Acc) ->
			  Itl2 = list_to_binary(integer_to_list(E)),
			  Itl3 = list_to_binary(js_mk_txt(T)),
			  [<< 
			    "if (document.getElementById('q",
			    Itl1/binary, "a", Itl2/binary,
			    "').checked) ", Varname/binary,
			    " += ", Itl3/binary, ";\n"
			    >>|Acc]
		  end, [], enumerate(Qs))).

gen_predef_html(Qid, Qs) ->
    lists:reverse(
      lists:foldl(fun({E, {T, _A}}, Acc) ->
			  Itl1 = list_to_binary(integer_to_list(Qid)),
			  Itl2 = list_to_binary(integer_to_list(E)),
			  Itl3 = list_to_binary(yaws_api:htmlize(T)),
			  [<<
			    "<input type='checkbox' id='q", Itl1/binary,
			    "a", Itl2/binary, "' />", Itl3/binary, "<br />"
			    >>|Acc]
		  end, [], enumerate(Qs))).

enumerate(E) ->
    enumerate(E, 1).
enumerate([E|R], C) ->
    [{C, E}] ++ enumerate(R, C + 1);
enumerate([], _C) ->
    [].

count(N) when is_integer(N), N > 0 ->
    count(N - 1) ++ [N];
count(0) ->
    [].
			    
	

js_mk_txt(Txt) -> %% TODO.
    "decodeURIComponent('" ++ yaws_api:url_encode(yaws_api:htmlize(Txt)) ++ "')".

now_secs() ->
    {A, B, _C} = now(),
    A * 1000000 + B.

</erl>
